Scalaire functie = Functie die 1 argument en 1 resultaat geeft. Voorbeeld:
	SQRT(4) = 2
Select is altijd de laatse stap in een statement. Deze bepaald welke kolommen er in het resultaat zullen zitten. (hoewel deze als eerste genoteerd is)
Select in een select enkel mogelijk wanneer de geneste select altijd 1 rij en 1 kolom als resutaat heeft.
From clause die specifieert een tabel, een select of een view, of een combinatie van de vorige.
View (Variabele) = select statement die opgelslaan is in de database. (ddl) Voorbeeld:
	CREATE VEIW [klantenUitBelgie]
	AS
	SELECT * FROM Customer
	WHERE Customer.Country = 'Belgium';
Views gebruiken als "from" in een SELECT statement. Voorbeeld:
	SELECT City
	From klantenUitBelgie
Select nesting in FROM clause. Voorbeeld:
	SELECT * 
	FROM (
		SELECT 123 AS getal
		) AS getallen1
	) AS getallen2

Performantie = aantal geheugen nodig om een statement uit te voeren (te controleren via een profiler) (vooral bij diep nesting in de FROM clause).
Execution plan (eenvoudige profiler) = Alle stappen die uitgevoerd worden om van een query een resultaat te bekomen. 
Natural join = inner join tussen 2 tabellen waar 2 kolommen met dezelfde naam gemerged worden.
SELECT TOP 10 * = geeft de eerste 10 resultaten. Wanneer dit gecombineerd is met een order by, wordt de "TOP" eerste uitgevoerd.
Union = operator die het resultaat van 2 statements combineert in 1 kolom, Hier kunnen geen dubbels in zitten (net zoals distinct) Voorbeeld:
	SELECT 123 as Alpha
	UNION
	SELECT 456 as Beta

De naam vd kolom is Alpha want dat is de alias van de eerste SELECT
EXCEPT = operator die het resultaat van SELECT 1 verminderd met het resultaat van SELECT 2.
INTERSECT = Operator die enkel het resultaat geeft die in beide alle SELECT's voorkomen (gemeenschappelijk zijn in alle SELECT's).
Kansberekening met deze operatoren. Voorbeeld:
SELECT *
FROM
(SELECT 1 c3 UNION SELECT 0) AS cijfer3
, (SELECT 1 c2 UNION SELECT 0) AS cijfer2
, (SELECT 1 c1 UNION SELECT 0) AS cijfer1
, (SELECT 1 c3 UNION SELECT 0) AS cijfer0
Dit zal alle mogelijke combinaties van 4 letters die 0/1 kunnen zijn weergeven.

GROUP BY = resultaat splitsen in groepen waarbij elke record maar 1 keer kan voorkomen (ingebouwde distinct) (creeert een groep waar bepaalde functies kunnen op uitgevoerd worden).
Op deze groepen kan je geen WHERE gebruiken maar gebruik je HAVING
Wanneer de eerste SELECT statement een WHERE clause heeft en een GROUP BY dan zal de WHERE clause eerst gebeuren en dan pas de GROUP BY. (alles weggefilterd door WHERE komt niet in de resulterende groepen terect)
Wanneer er iets in de GROUP BY clause staat dan kan deze ook in de SELECT komen, omgekeerd gaat niet.
ORDER BY kan je ook gebruiken om de groepen te groeperen.
Voorbeeld:
	SELECT FirstName
		, COUNT(*)
	FROM Customer
	WHERE LastName <> 'Philips'
	GROUP BY FirstName
	HAVING COUNT(*) > 1

Aggregate Funtions = Functies die 1 argument vereisen maar deze waarde moet een kolom zijn en Geeft 1 resultaat. Voorbeeld:
	AVG(Tabel X) die vraagt een kolom en zal daar dan het gemiddelde van returnen.

View is een veriabele in SQL waar een statement in is opgeslagen. Voorbeeld:
	Create view [Naam]

Volgorde uitvoering commando's = From, Where, Group by, Having, Order by, Select

Constraint: een statement waaraan de data in een table moet aan voldoen. Gebruikt in een CREATE TABLE statement

Normalisatie sql databases zie uitleg op engelstalige wikipedia.(verschillende normaalvormen)

Redundancie: gegevens komen meerder keren voor (op een andere manier), kan problemen geven bij relationele databases. Bijvoorbeeld: iemand is verhuist en zn adres moet gewijzigt worden.

Super sleutel: Een combinatie van 1 of meerdere kolommen waar je aan de hand van alle info in de rij kent.
Kandidaat sleutel: een supersleutel waar je geen kolom meer kan wegnemen om nog steeds een super sleutel te zijn. Uit deze kandidaat sleutels kies je de beste sleutel (primaire).
Primaire sleutel: Een kolom of een combinatie van kolommen die elke waarde in elke kolom uniek kan identificeren.

Voor de eindopracht zal je alle kandidaat sleutels moeten aanduiden6

Compositieve sleutel: Een sleutel die uit een combinatie van kolommen bestaat.
Unieke sleutel: Combinatie van kolomen die altijd uniek zullen zijn.
Foreing sleutel: 1 of meerdere kolommen uit een tabel verwijst naar de primaire sleutel van andere tabel.

Voorbeel creeren tabel met primary key:
	CREATE TABLE [dbo].ToothbrushModels (
		[ModelId] INT NOT NULL PRIMARY KEY
		,[Manufacturer] NCHAR(50) NOT NULL
		,[Model] NCHAR(50) NOT NULL
		,[ModelFullName] NCHAR(50) NOT NULL
		,[Country] NCHAR(50) NOT NULL
		CONSTRAINT AK_Tandenborstel UNIQUE KEY (Manufacturer, Model)
	)

1 veel relatie: 1 record in een tabel komt overeen met veel andere records uit een andere tabel.
Een foreign key kan toegevoegd worden aan de veel tabel en verwijst naar de 1 tabel

Database normaalvormen:

1NF
	1) Elke record heeft 1 value (atomicity).
	2) Elke record in een kolom moet gelijke data hebben vb: enkel namen in de "names" kolom opslaan.
	3) De volgorde van de kolommen maakt niet uit.
	4) Elke Kolom moet eem unieke naam hebben.
	5) Geen herhalende groepen vb: telefoon nummer 1 en telefoon nummer 2. (niet echt een regel maar een goede practice)

2NF
	1) Moet aan alle regels van de 1NF voldoen.
	2) Er mag geen partial dependency zijn. Een niet-primaire kolommen moeten afhangen van elke kolom uit de primaire sleutel.

3NF
	1) Moet aan alle regels van de 2NF voldoen.
	2) Er mag geen transitive dependency zijn. Een niet primaire kolom moet direct afhankelijk zijn van de primaire sleutel en niet van een andere niet-primaire kolom die afhankelijk is van de sleutel.

Eind opdracht zie wiki

"IDENTITY" kan je toevoegen aan een kolom, deze wordt dan automatisch ingevuld wanneer er een nieuwe record komt die deze kolom niet specifiek invuld. (een teller).
Standaard is het increment 1 (gaat dus met 1 omhoog).
Identity seed is de waarde waar het begint te tellen. 

SQL database maken:

1) Maak een nieuw project sql project in WGM

2) "Build" bouwt het project.

3) "Publisch" exporteert deze naar een databank. 
	"Generate script" zal het script om deze databank te maken genereren en tonen.\
		Hier bekijke je het script en kan je het nog eventueel aanpassen.
	"Publish" zal uiteindelijk het script uitvoeren.

Om een project aan te passen voer je ook dezelfde stappen uit. (maak je script, "build" je script, controleer je script, "publish" je script)

Tabels maken in een Database:
Ofwel rechtermuisknop in je Server object explorer -> add table
Ofwel via een query op de database zelf.

Sql script maken via sql server management studio:
Klik rechts op de database -> tasks -> generate scripts...
Volg de wizard
Kies de volledige database of sla enkele items over.
Zet alles in 1 bestand en let goed op de directory waar het bestand geplaatst wordt.
Klik op advanced
Types of data and script, kies schema en data.
Done

Transacties: een opvolging van 1 of meerdere statements (ACID = AtomicConsistentIsolatedDurable)
1) Atomisch: Meerdere statments in een transactie worden altijd als 1 uitgevoerd. Er is geen tijdens de transactie, enkel een voor en een na.
2) Consistent: Een statement kan de database niet invalid maken (bv een record maar half invullen)
3) Isolated: Tegelijk uitvoeren van een transactie (meerdere personenen die op dezelfde database werken) kan niet, deze worden altijd na elkaar uitgevoerd. De ene transactie ondervindt geen invloed van de andere.
4) Durable: Eenmaal de transactie is uitgevoerd, blijft het effect bestaan (zelfs na stroomuitval of onderbreking, aanwezig in alle databank systemen). bv wanneer een transactie uit 4 statements bestaat zullen alle 4 altijd uitgevoerd worden, nooit 2 wel en 2 niet bv. 

Transacties kunnen geschreven worden tussen de keywords:
	BEGIN TRANSACTION

	COMMIT
Met ROLLBACK kan je een statement in een transactie ongedaan maken, meestal vooraf gegaan door een predikaat zoals IF.
Met DECLARE kan je argumenten meegeven in een transactie (zowel gedeclareerde als ongedeclareerde variabellen).
	DECLARE @Naam varchar(100) = 'Diederik' 
	DECLARE @Achternaam varchar(100)
Deze argumenten aanroepen doe je met @.
Met SAVE TRANSACTION kan je een safe-point instellen zodat je kan terugkeren naar dat punt in de transactie, zo moet je niet de hele transactie ongedaan maken met ROLLBACK
	SAVE TRANSACTION safePointNaam

	ROLLBACK TRANSACTION safePointNaam

Procedure:Een deel statements opslaan om te hergebruiken.(een functie in sql)
Te vinden onder Databases > Database > Programmability > Stored Procedures
	CREATE PROCEDURE [dbo].procedurenaam
		eventuele argumenten
	AS
		de SQL-statements
	RETURN 0
Procedures kun je aanroepen dmv: 
	EXEC procedurenaam 'Parameter1', 'Parameter2'

Sequence: Een teller die met een bepaalde waarde begint en een bepaalde waarde omhoog gaat.
Bij een IDENTITY wordt er een achterliggende sequence aangemaakt.

Index: een naam die op een tabel of een view gedefineerd kan worden op basis van 1 of meerdere kolommen.
Dit wordt gebruikt wanneer je tabel traag begint te worden. Zo kan je werken met een beperkt aantal kolommen, wanneer je tabel te groot is of regelmatig geraadpleegt wordt.



Voorbeeld vragen dml examen:

/*

(3 punten)

Verwijder alles uit de tabel InvoiceLine.
--
Pas op! Andere vragen gaan er niet van uit dat er geen data in die tabel zit.
Zorg dus dat je de database kan herstellen
of het verwijderen ongedaan kan maken met rollback.

*/

/*

Geef de volgende informatie per unieke klant:

* voornaam (Customer.FirstName)
* familienaam (Customer.LastName)
* AantalFacturen: het aantal facturen
(records in tabel Invoice) per klant
* [Totaal uitgaven klant]: som van de totaalprijzen
van de facturen van de klant
* [Gemiddelde totaalprijs per factuur]: de gemiddelde
totaalprijs op de factuur per klant

Sorteer de resultaten volgens totale uitgaven
van elke klant. De klanten die meer gespendeerd
hebben komen voor de klanten die minder gespendeerd
hebben.

Hints:

* Facturen kan je vinden in de tabel Invoice
* De totaalprijs van een factuur kan je vinden
in de kolom Invoice.Total

*/

/*

Geef de FirstName, de LastName en Title kolommen
van de tabel Employee voor de employees die geen
vertegenwoordiger zijn voor klanten en die geen
"entry level" werknemers zijn.

Een "entry level" employee is een employee waarvoor
er geen andere employee is die ernaar verwijst
via de kolom ReportsTo.

Een vertegenwoordiger van een klant kan je vinden
via de foreign key FK_CustomerSupportRepId.

Hou geen rekening met klanten waarvoor SupportRepId
onbekend (dus NULL) is; dus laat die klanten weg.

*/